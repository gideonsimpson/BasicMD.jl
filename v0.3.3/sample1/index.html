<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling · BasicMD.jl</title><meta name="title" content="Sampling · BasicMD.jl"/><meta property="og:title" content="Sampling · BasicMD.jl"/><meta property="twitter:title" content="Sampling · BasicMD.jl"/><meta name="description" content="Documentation for BasicMD.jl."/><meta property="og:description" content="Documentation for BasicMD.jl."/><meta property="twitter:description" content="Documentation for BasicMD.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BasicMD.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Sampling</a><ul class="internal"><li><a class="tocitem" href="#Sampling-Trajectories-and-Boltzmann"><span>Sampling Trajectories and Boltzmann</span></a></li><li><a class="tocitem" href="#Sampling-Observables"><span>Sampling Observables</span></a></li><li><a class="tocitem" href="#Sampling-with-Constraints-and-Nonequilibrium-Proccesses"><span>Sampling with Constraints and Nonequilibrium Proccesses</span></a></li></ul></li><li><span class="tocitem">Samplers</span><ul><li><a class="tocitem" href="../samplers/metropolis1/">Metropolis Samplers</a></li><li><a class="tocitem" href="../samplers/nonmetropolis1/">Non-Metropolis Samplers</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../utils/opts1/">Options and Auxiliary Functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sample_traj1/">Sampling Trajectories</a></li><li><a class="tocitem" href="../examples/sample_obs1/">Sampling Observables</a></li><li><a class="tocitem" href="../examples/sample_con1/">Sampling with Constraints</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sampling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gideonsimpson/BasicMD.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gideonsimpson/BasicMD.jl/blob/master/docs/src/sample1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-and-Using-Samplers"><a class="docs-heading-anchor" href="#Creating-and-Using-Samplers">Creating and Using Samplers</a><a id="Creating-and-Using-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-Using-Samplers" title="Permalink"></a></h1><ul><li><a href="#Creating-and-Using-Samplers">Creating and Using Samplers</a></li><li class="no-marker"><ul><li><a href="#Sampling-Trajectories-and-Boltzmann">Sampling Trajectories and Boltzmann</a></li><li class="no-marker"><ul><li><a href="#Constructing-the-Sampler">Constructing the Sampler</a></li><li><a href="#Sampling-a-Trajectory">Sampling a Trajectory</a></li><li><a href="#Controlling-Output">Controlling Output</a></li></ul></li><li><a href="#Sampling-Observables">Sampling Observables</a></li><li><a href="#Sampling-with-Constraints-and-Nonequilibrium-Proccesses">Sampling with Constraints and Nonequilibrium Proccesses</a></li></ul></li></ul><h2 id="Sampling-Trajectories-and-Boltzmann"><a class="docs-heading-anchor" href="#Sampling-Trajectories-and-Boltzmann">Sampling Trajectories and Boltzmann</a><a id="Sampling-Trajectories-and-Boltzmann-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Trajectories-and-Boltzmann" title="Permalink"></a></h2><p>At their core, all of the included methods sample, approximately, from Botlzmann distributinos of the type <span>$\mu(x) \propto e^{-\beta V(x)}$</span>, where the user must specify the potential, <code>V(x)</code>, along with an appropriate inverse temperature, <code>β</code>.  </p><p>The potential, <code>V(x)</code>, must be formulated so that its input argument, <code>x</code> is an array, even if the problem is in <span>$\mathbb{R}^1$</span>.  For the scalar double well potential, <span>$V(x) = (x^2-1)^2$</span>, this would be implemneted as:</p><pre><code class="nohighlight hljs">function V(x)
    return (x[1]^2 -1)^2
end</code></pre><h3 id="Constructing-the-Sampler"><a class="docs-heading-anchor" href="#Constructing-the-Sampler">Constructing the Sampler</a><a id="Constructing-the-Sampler-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-Sampler" title="Permalink"></a></h3><p>Having defined the potential, a sampler object must first be defined.  For instance,</p><pre><code class="nohighlight hljs">rwm_sampler = RWM(V, β, Δt);</code></pre><p>constructs the random walk Metropolis (RWM) sampler for the Boltzmann disribution with `<code>time step&#39;&#39;</code>Δt`.</p><p>Other samplers require additional arguments.  For instance to use the HMC sampler, we would call</p><pre><code class="nohighlight hljs">sampler = HMC(V, gradV!, β, M, Δt, nΔt);</code></pre><p>where the additional arguments are:</p><ul><li><code>gradV!</code> -  in-place implementation of ∇V(x), </li><li><code>M</code> - mass matrix</li><li><code>nΔt</code> - number of Verlet steps of size <code>Δt</code> in each HMC iteration.</li><li></li></ul><h3 id="Sampling-a-Trajectory"><a class="docs-heading-anchor" href="#Sampling-a-Trajectory">Sampling a Trajectory</a><a id="Sampling-a-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-a-Trajectory" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BasicMD.sample_trajectory-Union{Tuple{S}, Tuple{Tx}, Tuple{Tx, S}} where {Tx, S&lt;:BasicMD.MetropolisSampler}" href="#BasicMD.sample_trajectory-Union{Tuple{S}, Tuple{Tx}, Tuple{Tx, S}} where {Tx, S&lt;:BasicMD.MetropolisSampler}"><code>BasicMD.sample_trajectory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_trajectory(x₀, sampler; options=MDOptions())</code></pre><p>Run the <code>sampler</code> starting at <code>x₀</code>.  Number of iterations and interval between saves are set using the <code>options</code> argument.  For Metropolis samplers, the running acceptance rates are also resturned.</p><p><strong>Fields</strong></p><ul><li><code>x₀</code>         - Starting position for sampler</li><li><code>sampler</code>   - Desired sampler</li></ul><p><strong>Optional Fields</strong></p><ul><li><code>options</code>   - Sampling options, including number of iteration</li><li><code>constraints</code> - Constraints on the trajectory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gideonsimpson/BasicMD.jl/blob/9e77bd389d3128505572aaa9ac304556040efc29/src/sample.jl#L25-L39">source</a></section></article><p>Having created the sampler strucutre and chosen an initial point, <code>x0</code>, we call <code>sample_trajectory</code>:</p><pre><code class="nohighlight hljs">xvals, avals = sampler_trajectory(x0, sampler);</code></pre><p>For a Metropolis sampler, like RWM, we return:</p><ul><li><code>xvals</code> - the array of sampled points</li><li><code>avals</code> - the running average of the acceptance rate For non-Metropolis</li></ul><p>samplers, the <code>avals</code> argument is not returned. </p><p>Examples:</p><ul><li><a href="../examples/sample_traj1/#Sampling-Trajectories">Sampling Trajectories</a></li><li class="no-marker"><ul><li><a href="../examples/sample_traj1/#RWM-Example">RWM Example</a></li><li><a href="../examples/sample_traj1/#HMC-Example">HMC Example</a></li><li><a href="../examples/sample_traj1/#Euler-Maruyama-Example">Euler-Maruyama Example</a></li><li><a href="../examples/sample_traj1/#ABOBA-Example">ABOBA Example</a></li></ul></li></ul><h3 id="Controlling-Output"><a class="docs-heading-anchor" href="#Controlling-Output">Controlling Output</a><a id="Controlling-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-Output" title="Permalink"></a></h3><p>The <code>sample_trajectory</code> command will allocates and returns an array of samples.  The number of iterations and the sampling frequency is controlled through the <code>options</code> argument.  By default, if this is not specified, the sampler will be called for 10^4 iterations, and record every iteration.  To change this, we construct an <a href="../utils/opts1/#BasicMD.MDOptions-Tuple{}"><code>MDOptions</code></a> structure and pass that in.</p><p>Additionally, one may be in the setting where we do not need to record the full trajectory, but merely the position at the terminal iterate.  This is handled with</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BasicMD.sample_trajectory!-Union{Tuple{S}, Tuple{Tx}, Tuple{Tx, S}} where {Tx, S&lt;:BasicMD.MetropolisSampler}" href="#BasicMD.sample_trajectory!-Union{Tuple{S}, Tuple{Tx}, Tuple{Tx, S}} where {Tx, S&lt;:BasicMD.MetropolisSampler}"><code>BasicMD.sample_trajectory!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_trajectory!(x, sampler; options=MDOptions())</code></pre><p>In place applciation of the <code>sampler</code> to <code>x</code>.  Number of iterations are set using the <code>options</code> argument.</p><p><strong>Fields</strong></p><ul><li><code>x</code>         - Starting position for sampler, modified in place</li><li><code>sampler</code>   - Desired sampler</li></ul><p><strong>Optional Fields</strong></p><ul><li><code>options</code>   - Sampling options, including number of iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gideonsimpson/BasicMD.jl/blob/9e77bd389d3128505572aaa9ac304556040efc29/src/sample.jl#L3-L15">source</a></section></article><h2 id="Sampling-Observables"><a class="docs-heading-anchor" href="#Sampling-Observables">Sampling Observables</a><a id="Sampling-Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Observables" title="Permalink"></a></h2><p>Often, one is not interested in the full trajectory <span>$\{X_t\}$</span>, but rather the time series observables computed on the trajectory.  Given a function <span>$f:\mathbb{R}^d\to \mathbb{R}$</span>, it may be satisfactory to simply know <span>$\{f(X_t)\}$</span>.  When <span>$d$</span> is high dimensional, only saving the observavble can cut computational cost and storage. Typically, this is done in order to estimate ergodic averages,</p><p class="math-container">\[\mathbb{E}_\mu[f(X)] = \int f(x)\mu(dx) \approx \frac{1}{n}\sum_{n=1}^n f(X_{t_n}).\]</p><p>This is accomplished using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BasicMD.sample_observables-Union{Tuple{NO}, Tuple{S}, Tuple{Tx}, Tuple{Tx, S, Tuple{Vararg{Function, NO}}}} where {Tx, S&lt;:BasicMD.AbstractSampler, NO}" href="#BasicMD.sample_observables-Union{Tuple{NO}, Tuple{S}, Tuple{Tx}, Tuple{Tx, S, Tuple{Vararg{Function, NO}}}} where {Tx, S&lt;:BasicMD.AbstractSampler, NO}"><code>BasicMD.sample_observables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_observables(x₀, sampler, observables; options=MDOptions())</code></pre><p>Run the <code>sampler</code> starting at <code>x₀</code>, evaluating the trajectory on a tuple of <code>observables</code> scalar functions.  Number of iterations and interval between saves are set using the <code>options</code> argument.  Only the computed observables are returned.</p><p><strong>Fields</strong></p><ul><li><code>x</code>         - Starting position for sampler, modified in place</li><li><code>sampler</code>   - Desired sampler</li><li><code>observables</code> - Observables on which to evaluate the trajectory</li></ul><p><strong>Optional Fields</strong></p><ul><li><code>TO</code>- Observable data type, if needed, should be entered as the first argument</li><li><code>options</code>   - Sampling options, including number of iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gideonsimpson/BasicMD.jl/blob/9e77bd389d3128505572aaa9ac304556040efc29/src/sample_observables.jl#L2-L16">source</a></section></article><p>This is quite similar to <code>sample_trajectory</code>, except that one must pass an additional argument, a structure containing the desired observables.  Additionally, only the time series of observables is returned, regardless of whether a Metropolis sampler is used or not.  </p><p>The <code>observables</code> argument should be a tuple of scalar valued functions, i.e. for a single observable:</p><pre><code class="nohighlight hljs">f(x) = x[1]; # first component
obs = (f,);</code></pre><p>and for multiple observables:</p><pre><code class="nohighlight hljs">f₁(x) = x[1]; # first component
f₂(x) = V(x); # energy
obs = (f₁,f₂);</code></pre><p>When calling the function,</p><pre><code class="nohighlight hljs">observable_traj = sample_observables(x₀, sampler,obs, options=opts);</code></pre><p>the returned object, <code>observable_traj</code> is a matrix.  Each row corresponding to an individual observable, recorded at the times specified by the <code>MDOptions</code>.</p><p>Examples:</p><ul><li><a href="../examples/sample_obs1/#Sampling-Observables">Sampling Observables</a></li><li class="no-marker"><ul><li><a href="../examples/sample_obs1/#RWM-Example">RWM Example</a></li><li><a href="../examples/sample_obs1/#HMC-Example">HMC Example</a></li><li><a href="../examples/sample_obs1/#ABOBA-Example">ABOBA Example</a></li></ul></li></ul><h2 id="Sampling-with-Constraints-and-Nonequilibrium-Proccesses"><a class="docs-heading-anchor" href="#Sampling-with-Constraints-and-Nonequilibrium-Proccesses">Sampling with Constraints and Nonequilibrium Proccesses</a><a id="Sampling-with-Constraints-and-Nonequilibrium-Proccesses-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-with-Constraints-and-Nonequilibrium-Proccesses" title="Permalink"></a></h2><p>Elementary, experimental, tools for enforcing constraints on the system, like <span>$X_t \in A$</span> or <span>$g(X_t)=0$</span> have been implemented.  This is accomplished by passing a <code>constraints</code> structure to one of <code>sample_trajectory!</code>, <code>sample_trajectory</code>, or <code>sample_obsevables</code>:</p><pre><code class="nohighlight hljs">traj = sample_trajectory(x₀, sampler, constraints);</code></pre><p>The constraints are constructed with</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BasicMD.Constraints" href="#BasicMD.Constraints"><code>BasicMD.Constraints</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constraints{TA, TB, TI}(before<em>update!::TA, after</em>update!::TB, n<em>before::TI, n</em>after::TI) where {TA, TB, TI&lt;:Integer}</p><p>Set constraints on the sampler, if desired</p><p><strong>Fields</strong></p><ul><li><code>before_update!</code> - Constraint to apply before a step of the sampler</li><li><code>after_update!</code>  - Constraint to apply after a step of the sampler</li><li><code>n_before</code> - Perform <code>before!</code> at <code>0, n_before-1, 2 n_before-1,...</code></li><li><code>n_after</code> - Perform <code>after!</code> at <code>n_after, 2 n_after,...</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gideonsimpson/BasicMD.jl/blob/9e77bd389d3128505572aaa9ac304556040efc29/src/constraints.jl#L1-L10">source</a></section></article><p><code>before_update!</code> and <code>after_update!</code> are in place transforms on the sampler&#39;s state type.  As their names imply, one is called before the sampler update step while the other is called after.  Additionally, they need not be executed at every step, and can instead be called every <code>n_before</code> or every <code>n_after</code> steps, as desired.  Set these to <code>1</code> and <code>1</code> if you wish to call them at every step.  <code>trivial_constraint!</code> is included, and may be used for either the <code>before_update!</code> or <code>after_update!</code> steps; this leaves the state undisturbed.</p><p>A key motivation for including this constraint module was to be able to sample from non-equilibrium steady states.  In particular, consider the case that we have a (continuous) trajectory, <span>$X_t$</span> with <span>$X_0 = x_0$</span>.  When <span>$X_t$</span> arrives at some set <span>$B$</span>, it <strong>recycles</strong> to <span>$x_0$</span>, and repeats.  Running this process to equilibrium and computing the particle flux into set <span>$B$</span> allows one to estimate the Mean First Passage Time (MFPT) form <span>$x_0\to B$</span>:</p><p class="math-container">\[\frac{1}{\text{MFPT}} = \lim_{T\to \infty} \frac{\text{Cumulative \# of arrivals at $B$ till time $T$}}{T} \]</p><p>This can be approximated in a finite time simulation with time step <span>$\Delta t$</span> by the expression</p><p class="math-container">\[\frac{1}{\text{MFPT}} \approx \frac{1}{N \Delta t } \sum_{k=0}^{N-1} 1_B(\tilde{X}_k)\]</p><p>Here, <span>$\tilde{X}_k$</span> is a modified discrete-in-time process that resets to <span>$x_0$</span> upon arrival at <span>$B$</span>. In the case that we are using an Euler-Maruyama integrator, this corresponds to</p><p class="math-container">\[\tilde{X}_{k+1} = \begin{cases} \tilde{X}_k - \nabla V(\tilde{X}_k) \Delta t   + \sqrt{2\beta^{-1}\Delta t}\xi_{k+1} &amp; \tilde{X}_k \notin B\\
x_0 &amp; \tilde{X}_k \in B
\end{cases}\]</p><p>Examples:</p><ul><li><a href="../examples/sample_con1/#Sampling-with-Constraints">Sampling with Constraints</a></li><li class="no-marker"><ul><li><a href="../examples/sample_con1/#Doublewell-Nonequilibrium-Steady-State">Doublewell Nonequilibrium Steady State</a></li></ul></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../samplers/metropolis1/">Metropolis Samplers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Thursday 18 April 2024 19:54">Thursday 18 April 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

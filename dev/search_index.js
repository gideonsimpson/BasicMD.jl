var documenterSearchIndex = {"docs":
[{"location":"samplers/metropolis1/#Metropolis-Samplers","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"","category":"section"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"These samplers include a Metropolis-Hastings style step that ensure that the Boltzmann distribution mu(x) propto e^-beta V(x) is exactly targeted; there is no bias associated with, for instance, a finite time step Δt.","category":"page"},{"location":"samplers/metropolis1/#Zeroth-Order-Methods","page":"Metropolis Samplers","title":"Zeroth Order Methods","text":"","category":"section"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"These are samplers which do not require the gradienet of the potential, ∇V.","category":"page"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"    RWM(V::TV, β::TF, Δt::TF) where{TV, TF<:AbstractFloat}","category":"page"},{"location":"samplers/metropolis1/#BasicMD.RWM-Union{Tuple{TF}, Tuple{TV}, Tuple{TV, TF, TF}} where {TV, TF<:AbstractFloat}","page":"Metropolis Samplers","title":"BasicMD.RWM","text":"RWM(V, β, Δt)\n\nSet up the RWM sampler for Boltzmann.\n\nFields\n\nV     - Potential\nβ     - Inverse temperature\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/metropolis1/#First-Order-Methods","page":"Metropolis Samplers","title":"First Order Methods","text":"","category":"section"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"These are samplers which require the gradienet of the potential, ∇V, and are in the spirit of first order in time discretizations.","category":"page"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"    MALA(V::TV,∇V!::TGV, β::TF, Δt::TF) where{TV, TGV, TF<:AbstractFloat}","category":"page"},{"location":"samplers/metropolis1/#BasicMD.MALA-Union{Tuple{TF}, Tuple{TGV}, Tuple{TV}, Tuple{TV, TGV, TF, TF}} where {TV, TGV, TF<:AbstractFloat}","page":"Metropolis Samplers","title":"BasicMD.MALA","text":"MALA(V, ∇V!, β, Δt)\n\nSet up the MALA sampler for overdamped Langevin.\n\nFields\n\nV     - Potential\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/metropolis1/#Second-Order-Methods","page":"Metropolis Samplers","title":"Second Order Methods","text":"","category":"section"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"These are samplers which require the gradienet of the potential, ∇V, and are in the spirit of second order in time discretizations.","category":"page"},{"location":"samplers/metropolis1/","page":"Metropolis Samplers","title":"Metropolis Samplers","text":"    HMC(V::TV, ∇V!::TGV, β::TF, M::TM, Δt::TF, nΔt::Int) where {TV, TGV, TF<:AbstractFloat,TM}","category":"page"},{"location":"samplers/metropolis1/#BasicMD.HMC-Union{Tuple{TM}, Tuple{TF}, Tuple{TGV}, Tuple{TV}, Tuple{TV, TGV, TF, TM, TF, Int64}} where {TV, TGV, TF<:AbstractFloat, TM}","page":"Metropolis Samplers","title":"BasicMD.HMC","text":"HMC(V, ∇V!, β, M, Δt, nΔt)\n\nSet up the HMC sampler for Boltzmann.\n\nFields\n\nV     - Potential\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nM     - Mass matrix\nΔt    - Time step\nnΔt   - Number of time steps to use in each Verlet run\n\n\n\n\n\n","category":"method"},{"location":"samplers/nonmetropolis1/#Non-Metropolis-Samplers","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"","category":"section"},{"location":"samplers/nonmetropolis1/","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"These methods do not include a Metropolis-Hastings step, and, consequently, will sample from a distribution, mu_Delta t(x), which is a biased approximation of mu(x) propto e^-beta V(x).   This bias vanishes with Δt, and is often negligible in comparison to the statistical variance error.","category":"page"},{"location":"samplers/nonmetropolis1/#First-Order-Methods","page":"Non-Metropolis Samplers","title":"First Order Methods","text":"","category":"section"},{"location":"samplers/nonmetropolis1/","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"These methods are in the spirit of first order in time discretizations.","category":"page"},{"location":"samplers/nonmetropolis1/","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"    EM(∇V!::TGV, β::TF, Δt::TF) where{TGV, TF<:AbstractFloat}","category":"page"},{"location":"samplers/nonmetropolis1/#BasicMD.EM-Union{Tuple{TF}, Tuple{TGV}, Tuple{TGV, TF, TF}} where {TGV, TF<:AbstractFloat}","page":"Non-Metropolis Samplers","title":"BasicMD.EM","text":"EM(∇V!, β, γ, M, Δt)\n\nSet up the EM integrator for overdamped Langevin.\n\nFields\n\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/nonmetropolis1/#Second-Order-Methods","page":"Non-Metropolis Samplers","title":"Second Order Methods","text":"","category":"section"},{"location":"samplers/nonmetropolis1/","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"These methods are in the spirit of second order in time discretizations.","category":"page"},{"location":"samplers/nonmetropolis1/","page":"Non-Metropolis Samplers","title":"Non-Metropolis Samplers","text":"    ABOBA(∇V!::TGV, β::TF, γ::TF, M::TM, Δt::TF) where {TGV, TF<:AbstractFloat,TM}\n    BAOAB(∇V!::TGV, β::TF, γ::TF, M::TM, Δt::TF) where {TGV, TF<:AbstractFloat,TM}\n    BBK(∇V!::TGV, β::TF, γ::TF, M::TM, Δt::TF) where {TGV, TF<:AbstractFloat,TM}\n    GJF(∇V!::TGV, β::TF, γ::TF, M::TM, Δt::TF) where {TGV, TF<:AbstractFloat,TM}","category":"page"},{"location":"samplers/nonmetropolis1/#BasicMD.ABOBA-Union{Tuple{TM}, Tuple{TF}, Tuple{TGV}, Tuple{TGV, TF, TF, TM, TF}} where {TGV, TF<:AbstractFloat, TM}","page":"Non-Metropolis Samplers","title":"BasicMD.ABOBA","text":"ABOBA(∇V!, β, γ, M, Δt)\n\nSet up the ABOBA integrator for inertial Langevin.\n\nFields\n\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nγ     - Damping Coefficient\nM     - Mass (either scalar or vector)\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/nonmetropolis1/#BasicMD.BAOAB-Union{Tuple{TM}, Tuple{TF}, Tuple{TGV}, Tuple{TGV, TF, TF, TM, TF}} where {TGV, TF<:AbstractFloat, TM}","page":"Non-Metropolis Samplers","title":"BasicMD.BAOAB","text":"BAOAB(∇V!, β, γ, M, Δt)\n\nSet up the BAOAB integrator for inertial Langevin.\n\nFields\n\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nγ     - Damping Coefficient\nM     - Mass (either scalar or vector)\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/nonmetropolis1/#BasicMD.BBK-Union{Tuple{TM}, Tuple{TF}, Tuple{TGV}, Tuple{TGV, TF, TF, TM, TF}} where {TGV, TF<:AbstractFloat, TM}","page":"Non-Metropolis Samplers","title":"BasicMD.BBK","text":"BBK(∇V!, β, γ, M, Δt)\n\nSet up the BBK integrator for inertial Langevin.\n\nFields\n\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nγ     - Damping Coefficient\nM     - Mass (either scalar or vector)\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"samplers/nonmetropolis1/#BasicMD.GJF-Union{Tuple{TM}, Tuple{TF}, Tuple{TGV}, Tuple{TGV, TF, TF, TM, TF}} where {TGV, TF<:AbstractFloat, TM}","page":"Non-Metropolis Samplers","title":"BasicMD.GJF","text":"GJF(∇V!, β, γ, M, Δt)\n\nSet up the G-JF integrator for inertial Langevin.\n\nFields\n\n∇V!   - In place gradient of the potential\nβ     - Inverse temperature\nγ     - Damping Coefficient\nM     - Mass (either scalar or vector)\nΔt    - Time step\n\n\n\n\n\n","category":"method"},{"location":"sample1/#Creating-and-Using-Samplers","page":"Sampling","title":"Creating and Using Samplers","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"Pages = [\"sample1.md\"]\nDepth = 4","category":"page"},{"location":"sample1/#Sampling-Boltzmann","page":"Sampling","title":"Sampling Boltzmann","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"At their core, all of the included methods sample, approximately, from Botlzmann distributinos of the type mu(x) propto e^-beta V(x), where the user must specify the potential, V(x), along with an appropriate inverse temperature, β.  ","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"The potential, V(x), must be formulated so that its input argument, x is an array, even if the problem is in mathbbR^1.  For the scalar double well potential, V(x) = (x^2-1)^2, this would be implemneted as:","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"function V(x)\n    return (x[1]^2 -1)^2\nend","category":"page"},{"location":"sample1/#Constructing-the-Sampler","page":"Sampling","title":"Constructing the Sampler","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"Having defined the potential, a sampler object must first be defined.  For instance,","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"rwm_sampler = RWM(V, β, Δt);","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"constructs the random walk Metropolis (RWM) sampler for the Boltzmann disribution with `time step''Δt`.","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"Other samplers require additional arguments.  For instance to use the HMC sampler, we would call","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"sampler = HMC(V, gradV!, β, M, Δt, nΔt);","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"where the additional arguments are:","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"gradV! -  in-place implementation of ∇V(x), \nM - mass matrix\nnΔt - number of Verlet steps of size Δt in each HMC iteration.\n","category":"page"},{"location":"sample1/#Sampling-a-Trajectory","page":"Sampling","title":"Sampling a Trajectory","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"    sample_trajectory","category":"page"},{"location":"sample1/#BasicMD.sample_trajectory","page":"Sampling","title":"BasicMD.sample_trajectory","text":"sample_trajectory(x₀, sampler; options=MDOptions())\n\nRun the sampler starting at x₀.  Number of iterations and interval between saves are set using the options argument.  For Metropolis samplers, the running acceptance rates are also resturned.\n\nFields\n\nx₀         - Starting position for sampler, modified in place\nsampler   - Desired sampler\n\nOptional Fields\n\noptions   - Sampling options, including number of iteration\nconstraints - Constraints on the trajectory\n\n\n\n\n\nsample_trajectory(x₀, sampler; options=MDOptions())\n\nRun the sampler starting at x₀.  Number of iterations and interval between saves are set using the options argument.  For Metropolis samplers, the running acceptance rates are also resturned.\n\nFields\n\nx         - Starting position for sampler, modified in place\nsampler   - Desired sampler\nconstraints - Constraints on the trajectory\n\nOptional Fields\n\noptions   - Sampling options, including number of iteration\n\n\n\n\n\n","category":"function"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"Having created the sampler strucutre and chosen an initial point, x0, we call sample_trajectory:","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"xvals, avals = sampler_trajectory(x0, sampler);","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"For a Metropolis sampler, like RWM, we return:","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"xvals - the array of sampled points\navals - the running average of the acceptance rate For non-Metropolis","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"samplers, the avals argument is not returned. ","category":"page"},{"location":"sample1/#RWM-Example","page":"Sampling","title":"RWM Example","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"using Plots\nusing Printf\nusing Random\nusing BasicMD\n\nfunction V(x)\n    return (x[1]^2 -1)^2\nend\n\nβ = 5.0;\nx0 = [-1.0];\nseed = 100;\nΔt = 1e-1;\nn_iters = 10^4; # number of samples\n\nsampler = RWM(V, β, Δt);\n\nRandom.seed!(100);\n\nxvals, avals = sample_trajectory(x0, sampler, options=MDOptions(n_iters=n_iters));\n\nhistogram([x_[1] for x_ in xvals],label=\"RWM Samples\",normalize=true)\nxlabel!(\"x\")\nylabel!(\"Frequency\")","category":"page"},{"location":"sample1/#HMC-Example","page":"Sampling","title":"HMC Example","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"using Plots\nusing Printf\nusing Random\nusing BasicMD\nusing ForwardDiff\n\nfunction V(x)\n    return (x[1]^2 -1)^2\nend\n\ngradV! = (gradV, x)-> ForwardDiff.gradient!(gradV, V, x);\n\n\nβ = 5.0;\nx0 = [-1.0];\nseed = 100;\nM = 1.;\nnΔt = 10^1; # number of Verlet steps per HMC iteration\nΔt = 1e-1;\nn_iters = 10^4; # number of samples\n\nsampler = HMC(V, gradV!, β, M, Δt, nΔt);\n\nRandom.seed!(100);\n\nxvals, avals = sample_trajectory(x0, sampler, options=MDOptions(n_iters=n_iters));\n\nhistogram([x_[1] for x_ in xvals],label=\"HMC Samples\",normalize=true)\nxlabel!(\"x\")\nylabel!(\"Frequency\")","category":"page"},{"location":"sample1/#Euler-Maruyama-Example","page":"Sampling","title":"Euler-Maruyama Example","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"using Plots\nusing Printf\nusing Random\nusing BasicMD\nusing ForwardDiff\n\nfunction V(x)\n    return (x[1]^2 -1)^2\nend\n\ngradV! = (gradV, x)-> ForwardDiff.gradient!(gradV, V, x);\n\n\nβ = 5.0;\nx0 = [-1.0];\nseed = 100;\nΔt = 1e-1;\nn_iters = 10^4; # number of samples\n\nsampler = EM(gradV!, β, Δt);\n\nRandom.seed!(100);\n\nxvals = sample_trajectory(x0, sampler, options=MDOptions(n_iters=n_iters));\n\nhistogram([x_[1] for x_ in xvals],label=\"EM Samples\",normalize=true)\nxlabel!(\"x\")\nylabel!(\"Frequency\")","category":"page"},{"location":"sample1/#ABOBA-Example","page":"Sampling","title":"ABOBA Example","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"using Plots\nusing Printf\nusing Random\nusing BasicMD\nusing ForwardDiff\n\nfunction V(x)\n    return (x[1]^2 -1)^2\nend\n\ngradV! = (gradV, x)-> ForwardDiff.gradient!(gradV, V, x);\n\n\nβ = 5.0;\nγ = 1.;\nM = 1.;\nq0 = [-1.0];\np0 = [0.0]; # as ABOBA is an inertial sampler, we need to specify a momentum\nx0 = [copy(q0), copy(p0)];\nseed = 100;\nΔt = 1e-1;\nn_iters = 10^4; # number of samples\n\nsampler = ABOBA(gradV!, β, γ, M, Δt);\nopts = MDOptions(n_iters=n_iters);\n\nRandom.seed!(100);\nxvals = sample_trajectory(x0, sampler, options= opts);\n\nhistogram([x_[1][1] for x_ in xvals],label=\"ABOBA Samples\",normalize=true)\nxlabel!(\"x\")\nylabel!(\"Frequency\")","category":"page"},{"location":"sample1/#Controlling-Output","page":"Sampling","title":"Controlling Output","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"The sample_trajectory command will allocates and returns an array of samples.  The number of iterations and the sampling frequency is controlled through the options argument.  By default, if this is not specified, the sampler will be called for 10^4 iterations, and record every iteration.  To change this, we construct an MDOptions structure and pass that in.","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"Additionally, one may be in the setting where we do not need to record the full trajectory, but merely the position at the terminal iterate.  This is handled with","category":"page"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"    sample_trajectory!","category":"page"},{"location":"sample1/#BasicMD.sample_trajectory!","page":"Sampling","title":"BasicMD.sample_trajectory!","text":"sample_trajectory!(x, sampler; options=MDOptions())\n\nIn place applciation of the sampler to x.  Number of iterations are set using the options argument.\n\nFields\n\nx         - Starting position for sampler, modified in place\nsampler   - Desired sampler\n\nOptional Fields\n\noptions   - Sampling options, including number of iteration\n\n\n\n\n\nsample_trajectory!(x, sampler; options=MDOptions())\n\nIn place applciation of the sampler to x.  Number of iterations are set using the options argument.\n\nFields\n\nx         - Starting position for sampler, modified in place\nsampler   - Desired sampler\nconstraints - Constraints on the trajectory\n\nOptional Fields\n\noptions   - Sampling options, including number of iteration\n\n\n\n\n\n","category":"function"},{"location":"sample1/#Sampling-Observables","page":"Sampling","title":"Sampling Observables","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"TBW","category":"page"},{"location":"sample1/#Sampling-with-Constraints-(EXPERIMENTAL)","page":"Sampling","title":"Sampling with Constraints (EXPERIMENTAL)","text":"","category":"section"},{"location":"sample1/","page":"Sampling","title":"Sampling","text":"TBW","category":"page"},{"location":"utils/opts1/#Options-and-Auxiliary-Functions","page":"Options and Auxiliary Functions","title":"Options and Auxiliary Functions","text":"","category":"section"},{"location":"utils/opts1/#Sampler-Options","page":"Options and Auxiliary Functions","title":"Sampler Options","text":"","category":"section"},{"location":"utils/opts1/","page":"Options and Auxiliary Functions","title":"Options and Auxiliary Functions","text":"These options set the number of iterations and the frequency at which data is recorderd.  This is generically used by all samplers.","category":"page"},{"location":"utils/opts1/","page":"Options and Auxiliary Functions","title":"Options and Auxiliary Functions","text":"    MDOptions(; n_iters = 10^4, n_save_iters = 1)","category":"page"},{"location":"utils/opts1/#BasicMD.MDOptions-Tuple{}","page":"Options and Auxiliary Functions","title":"BasicMD.MDOptions","text":"MDOptions(;n_iters = 10^4, n_save_iters=1)\n\nSet options for samplers.\n\nFields\n\nn_iters       - Set the number of iterations of the sampler\nnsaveiters  - Set the frequency at which iterations are saved.  If                 nsaveiters=1, every iteration is saved.  If nsaveiters=n_iters,                 only the final iteration is saved.\n\n\n\n\n\n","category":"method"},{"location":"utils/opts1/#Verlet-Integrator","page":"Options and Auxiliary Functions","title":"Verlet Integrator","text":"","category":"section"},{"location":"utils/opts1/","page":"Options and Auxiliary Functions","title":"Options and Auxiliary Functions","text":"While the main goal of this package is to sample from NVT type ensembles, as it is needed for HMC, the Verlet integrator is included should one wish to sample from the NVE ensemble:","category":"page"},{"location":"utils/opts1/","page":"Options and Auxiliary Functions","title":"Options and Auxiliary Functions","text":"    Verlet","category":"page"},{"location":"utils/opts1/#BasicMD.Verlet","page":"Options and Auxiliary Functions","title":"BasicMD.Verlet","text":"Verlet(∇V!, M, Δt)\n\nSet up the Verlet integrator.\n\nFields\n\n∇V!   - In place gradient of the potential\nM     - Mass (either scalar or vector)\nΔt    - Time step\n\n\n\n\n\n","category":"type"},{"location":"#BasicMD.jl-Documentation","page":"Home","title":"BasicMD.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a collection of basic routines for Molecular Dynamics simulations written in Julia.  These include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Euler–Maruyama (EM)\nRandom Walk Metropolis (RWM)\nMetropolis Adjusted Langevin (MALA)\nBrünger, Brooks and Karplus (BBK)\nGrønbech-Jensen and Farago (GJF)\nABOBA, BAOAB\nHamiltonian/Hybrid Monte Carlo (HMC)","category":"page"},{"location":"#Caveats","page":"Home","title":"Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code assumes that the state space is vector valued.  Thus, even if the problem is one dimensional, you should have initial points and functions formatted appropriately, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"> x0 = [1.0]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The mass matrix, M, used in the inertial Langevin integrators and Hamiltonian methods must be diagonal and provided either as a scalar (in the isotropic case) or a vector (in the anisotropic case).  This restriction is in place for performance purposes.\nBBK is currently implemented for a slightly different version of the Langevin SDE than ABOBA/BAOAB.  BBK requires inverting the mass matrix while ABOBA/BAOAB require its square root.\nGJF is implemented in (q,p) coordinates as opposed to (x,v) coordinates. Consequently, the mass term appears slightly differently than in the literature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both will sample the associated Boltzmann distribution, but the SDE trajectories will differ when M≂̸I.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported in part by the US National Science Foundation Grant DMS-1818716.","category":"page"}]
}
